# What I want
- Sum types
- Non manual-memory management
- Multiple return
- (questionable) Functions instead of Traits (declare dependence on functions as compile time args)
- (questionable) Functions instead of methods but with syntax sugar as if they are methods.
- type aliases (no type declaration necessary with convenient algebraic type syntax (tuples and variants/enums))
- Compile time args/fields
- Built in support (with parameters) for
  - arrays (statically sized)
  - lists (dynamic arrays and linked lists)
  - maps (Open-addressing hashmap)
  - sets (-- || -- hashset) 
  - ranges
  - chars (just syntax sugar for an integer (it's the utf-8 code-point))
  - strings (just syntax sugar for an array of bytes)
  - Any size of integers (Signed: Sxx, Unsigned: Uxx)
  - different bases (hex, oct, decimal, binary)
- recursive userdefined data-types (could make builtin linked lists unnecessary which is good)
- first-class functions/functions as values
- list/map/set Comprehension
- loop (pattern matching condition)
- match (pattern matching)
- Pattern matching
- Generic functions
- Generic user types
- Arithmetic operators (^,!,*,/,-,+,=,!=,<,>,<=,>=) (chained operators allowed!)
- Boolean operators (and, or, not, xor) (warning if ambiguous)
- (questionable) Make Boolean operators usable for all enum types. No builtin Boolean type necessary.
- Syntax defined entirely in internationally accepted ad standardised symbols (= + : ( ) -> [] {} etc ...)
- All builtin types have no names, they are used only through symbols [] {} etc ... (hmm integers?) (the bit size is fine, arabic numerals are standardized, unsigned/signed? hmmm, find some nice symbols)
- ; and {} is allowed but not necessary. Alternatively just use parenthesis
- user defined names can be in any utf-8 characters (except for the ones used in the syntax ofc) (international. japanese, chinese, korean, swedish etc...)
- This means capitalization is not viable for differentiating types from values. hmmmm... problematic ...  needs more pondering.
