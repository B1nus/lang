# What I want
- Sum types
- Non manual-memory management
- Multiple return
- (questionable) Functions instead of Traits (declare dependence on functions as compile time args)
- (questionable) Functions instead of methods but with syntax sugar as if they are methods.
- Compile time args/fields
- Built in support (with parameters) for
  - arrays (statically sized)
  - lists (dynamic arrays and linked lists)
  - maps (Open-addressing hashmap)
  - sets (-- || -- hashset) 
  - ranges
  - chars (just syntax sugar for an integer (it's the utf-8 code-point))
  - strings (just syntax sugar for an array of bytes)
  - Any size of integers (Signed: Sxx, Unsigned: Uxx)
  - different bases (hex, oct, decimal, binary)
- recursive userdefined data-types (could make builtin linked lists unnecessary which is good)
- first-class functions/functions as values
- list/map/set Comprehension
- loop (pattern matching condition)
- match (pattern matching)
- Pattern matching
- Generic functions
- Generic user types
- Arithmetic operators (^,!,*,/,-,+,=,!=,<,>,<=,>=) (chained operators allowed!)
- Boolean operators (and, or, not, xor) (warning if ambiguous)
- (questionable) Make Boolean operators usable for all enum types. No builtin Boolean type necessary.
